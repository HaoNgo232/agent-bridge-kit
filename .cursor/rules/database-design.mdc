---
description: 
globs: **/*.sql,**/prisma/**/*,**/drizzle/**/*,**/migrations/**/*
alwaysApply: false
---

# Database Design

> **Learn to THINK, not copy SQL patterns.**

## ðŸŽ¯ Selective Reading Rule

**Read ONLY files relevant to the request!** Check the content map, find what you need.

| File | Description | When to Read |
|------|-------------|--------------|
| `database-selection.md` | PostgreSQL vs Neon vs Turso vs SQLite | Choosing database |
| `orm-selection.md` | Drizzle vs Prisma vs Kysely | Choosing ORM |
| `schema-design.md` | Normalization, PKs, relationships | Designing schema |
| `indexing.md` | Index types, composite indexes | Performance tuning |
| `optimization.md` | N+1, EXPLAIN ANALYZE | Query optimization |
| `migrations.md` | Safe migrations, serverless DBs | Schema changes |

---

## âš ï¸ Core Principle

- ASK user for database preferences when unclear
- Choose database/ORM based on CONTEXT
- Don't default to PostgreSQL for everything

---

## Decision Checklist

Before designing schema:

- [ ] Asked user about database preference?
- [ ] Chosen database for THIS context?
- [ ] Considered deployment environment?
- [ ] Planned index strategy?
- [ ] Defined relationship types?

---

## Anti-Patterns

âŒ Default to PostgreSQL for simple apps (SQLite may suffice)
âŒ Skip indexing
âŒ Use SELECT * in production
âŒ Store JSON when structured data is better
âŒ Ignore N+1 queries


---

# Database Selection (2025)

> Choose database based on context, not default.

## Decision Tree

```
What are your requirements?
â”‚
â”œâ”€â”€ Full relational features needed
â”‚   â”œâ”€â”€ Self-hosted â†’ PostgreSQL
â”‚   â””â”€â”€ Serverless â†’ Neon, Supabase
â”‚
â”œâ”€â”€ Edge deployment / Ultra-low latency
â”‚   â””â”€â”€ Turso (edge SQLite)
â”‚
â”œâ”€â”€ AI / Vector search
â”‚   â””â”€â”€ PostgreSQL + pgvector
â”‚
â”œâ”€â”€ Simple / Embedded / Local
â”‚   â””â”€â”€ SQLite
â”‚
â””â”€â”€ Global distribution
    â””â”€â”€ PlanetScale, CockroachDB, Turso
```

## Comparison

| Database | Best For | Trade-offs |
|----------|----------|------------|
| **PostgreSQL** | Full features, complex queries | Needs hosting |
| **Neon** | Serverless PG, branching | PG complexity |
| **Turso** | Edge, low latency | SQLite limitations |
| **SQLite** | Simple, embedded, local | Single-writer |
| **PlanetScale** | MySQL, global scale | No foreign keys |

## Questions to Ask

1. What's the deployment environment?
2. How complex are the queries?
3. Is edge/serverless important?
4. Vector search needed?
5. Global distribution required?


---

# Indexing Principles

> When and how to create indexes effectively.

## When to Create Indexes

```
Index these:
â”œâ”€â”€ Columns in WHERE clauses
â”œâ”€â”€ Columns in JOIN conditions
â”œâ”€â”€ Columns in ORDER BY
â”œâ”€â”€ Foreign key columns
â””â”€â”€ Unique constraints

Don't over-index:
â”œâ”€â”€ Write-heavy tables (slower inserts)
â”œâ”€â”€ Low-cardinality columns
â”œâ”€â”€ Columns rarely queried
```

## Index Type Selection

| Type | Use For |
|------|---------|
| **B-tree** | General purpose, equality & range |
| **Hash** | Equality only, faster |
| **GIN** | JSONB, arrays, full-text |
| **GiST** | Geometric, range types |
| **HNSW/IVFFlat** | Vector similarity (pgvector) |

## Composite Index Principles

```
Order matters for composite indexes:
â”œâ”€â”€ Equality columns first
â”œâ”€â”€ Range columns last
â”œâ”€â”€ Most selective first
â””â”€â”€ Match query pattern
```


---

# Migration Principles

> Safe migration strategy for zero-downtime changes.

## Safe Migration Strategy

```
For zero-downtime changes:
â”‚
â”œâ”€â”€ Adding column
â”‚   â””â”€â”€ Add as nullable â†’ backfill â†’ add NOT NULL
â”‚
â”œâ”€â”€ Removing column
â”‚   â””â”€â”€ Stop using â†’ deploy â†’ remove column
â”‚
â”œâ”€â”€ Adding index
â”‚   â””â”€â”€ CREATE INDEX CONCURRENTLY (non-blocking)
â”‚
â””â”€â”€ Renaming column
    â””â”€â”€ Add new â†’ migrate data â†’ deploy â†’ drop old
```

## Migration Philosophy

- Never make breaking changes in one step
- Test migrations on data copy first
- Have rollback plan
- Run in transaction when possible

## Serverless Databases

### Neon (Serverless PostgreSQL)

| Feature | Benefit |
|---------|---------|
| Scale to zero | Cost savings |
| Instant branching | Dev/preview |
| Full PostgreSQL | Compatibility |
| Autoscaling | Traffic handling |

### Turso (Edge SQLite)

| Feature | Benefit |
|---------|---------|
| Edge locations | Ultra-low latency |
| SQLite compatible | Simple |
| Generous free tier | Cost |
| Global distribution | Performance |


---

# Query Optimization

> N+1 problem, EXPLAIN ANALYZE, optimization priorities.

## N+1 Problem

```
What is N+1?
â”œâ”€â”€ 1 query to get parent records
â”œâ”€â”€ N queries to get related records
â””â”€â”€ Very slow!

Solutions:
â”œâ”€â”€ JOIN â†’ Single query with all data
â”œâ”€â”€ Eager loading â†’ ORM handles JOIN
â”œâ”€â”€ DataLoader â†’ Batch and cache (GraphQL)
â””â”€â”€ Subquery â†’ Fetch related in one query
```

## Query Analysis Mindset

```
Before optimizing:
â”œâ”€â”€ EXPLAIN ANALYZE the query
â”œâ”€â”€ Look for Seq Scan (full table scan)
â”œâ”€â”€ Check actual vs estimated rows
â””â”€â”€ Identify missing indexes
```

## Optimization Priorities

1. **Add missing indexes** (most common issue)
2. **Select only needed columns** (not SELECT *)
3. **Use proper JOINs** (avoid subqueries when possible)
4. **Limit early** (pagination at database level)
5. **Cache** (when appropriate)


---

# ORM Selection (2025)

> Choose ORM based on deployment and DX needs.

## Decision Tree

```
What's the context?
â”‚
â”œâ”€â”€ Edge deployment / Bundle size matters
â”‚   â””â”€â”€ Drizzle (smallest, SQL-like)
â”‚
â”œâ”€â”€ Best DX / Schema-first
â”‚   â””â”€â”€ Prisma (migrations, studio)
â”‚
â”œâ”€â”€ Maximum control
â”‚   â””â”€â”€ Raw SQL with query builder
â”‚
â””â”€â”€ Python ecosystem
    â””â”€â”€ SQLAlchemy 2.0 (async support)
```

## Comparison

| ORM | Best For | Trade-offs |
|-----|----------|------------|
| **Drizzle** | Edge, TypeScript | Newer, less examples |
| **Prisma** | DX, schema management | Heavier, not edge-ready |
| **Kysely** | Type-safe SQL builder | Manual migrations |
| **Raw SQL** | Complex queries, control | Manual type safety |


---

# Schema Design Principles

> Normalization, primary keys, timestamps, relationships.

## Normalization Decision

```
When to normalize (separate tables):
â”œâ”€â”€ Data is repeated across rows
â”œâ”€â”€ Updates would need multiple changes
â”œâ”€â”€ Relationships are clear
â””â”€â”€ Query patterns benefit

When to denormalize (embed/duplicate):
â”œâ”€â”€ Read performance critical
â”œâ”€â”€ Data rarely changes
â”œâ”€â”€ Always fetched together
â””â”€â”€ Simpler queries needed
```

## Primary Key Selection

| Type | Use When |
|------|----------|
| **UUID** | Distributed systems, security |
| **ULID** | UUID + sortable by time |
| **Auto-increment** | Simple apps, single database |
| **Natural key** | Rarely (business meaning) |

## Timestamp Strategy

```
For every table:
â”œâ”€â”€ created_at â†’ When created
â”œâ”€â”€ updated_at â†’ Last modified
â””â”€â”€ deleted_at â†’ Soft delete (if needed)

Use TIMESTAMPTZ (with timezone) not TIMESTAMP
```

## Relationship Types

| Type | When | Implementation |
|------|------|----------------|
| **One-to-One** | Extension data | Separate table with FK |
| **One-to-Many** | Parent-children | FK on child table |
| **Many-to-Many** | Both sides have many | Junction table |

## Foreign Key ON DELETE

```
â”œâ”€â”€ CASCADE â†’ Delete children with parent
â”œâ”€â”€ SET NULL â†’ Children become orphans
â”œâ”€â”€ RESTRICT â†’ Prevent delete if children exist
â””â”€â”€ SET DEFAULT â†’ Children get default value
```
