---
description: 
globs: **/api/**/*,**/routes/**/*,**/*.controller.*,**/*.service.*
alwaysApply: false
---

# API Patterns

> API design principles and decision-making for 2025.
> **Learn to THINK, not copy fixed patterns.**

## ğŸ¯ Selective Reading Rule

**Read ONLY files relevant to the request!** Check the content map, find what you need.

---

## ğŸ“‘ Content Map

| File | Description | When to Read |
|------|-------------|--------------|
| `api-style.md` | REST vs GraphQL vs tRPC decision tree | Choosing API type |
| `rest.md` | Resource naming, HTTP methods, status codes | Designing REST API |
| `response.md` | Envelope pattern, error format, pagination | Response structure |
| `graphql.md` | Schema design, when to use, security | Considering GraphQL |
| `trpc.md` | TypeScript monorepo, type safety | TS fullstack projects |
| `versioning.md` | URI/Header/Query versioning | API evolution planning |
| `auth.md` | JWT, OAuth, Passkey, API Keys | Auth pattern selection |
| `rate-limiting.md` | Token bucket, sliding window | API protection |
| `documentation.md` | OpenAPI/Swagger best practices | Documentation |
| `security-testing.md` | OWASP API Top 10, auth/authz testing | Security audits |

---

## ğŸ”— Related Skills

| Need | Skill |
|------|-------|
| API implementation | `@[skills/backend-development]` |
| Data structure | `@[skills/database-design]` |
| Security details | `@[skills/security-hardening]` |

---

## âœ… Decision Checklist

Before designing an API:

- [ ] **Asked user about API consumers?**
- [ ] **Chosen API style for THIS context?** (REST/GraphQL/tRPC)
- [ ] **Defined consistent response format?**
- [ ] **Planned versioning strategy?**
- [ ] **Considered authentication needs?**
- [ ] **Planned rate limiting?**
- [ ] **Documentation approach defined?**

---

## âŒ Anti-Patterns

**DON'T:**
- Default to REST for everything
- Use verbs in REST endpoints (/getUsers)
- Return inconsistent response formats
- Expose internal errors to clients
- Skip rate limiting

**DO:**
- Choose API style based on context
- Ask about client requirements
- Document thoroughly
- Use appropriate status codes

---

## Script

| Script | Purpose | Command |
|--------|---------|---------|
| `scripts/api_validator.py` | API endpoint validation | `python scripts/api_validator.py <project_path>` |



---

# API Style Selection (2025)

> REST vs GraphQL vs tRPC - Hangi durumda hangisi?

## Decision Tree

```
Who are the API consumers?
â”‚
â”œâ”€â”€ Public API / Multiple platforms
â”‚   â””â”€â”€ REST + OpenAPI (widest compatibility)
â”‚
â”œâ”€â”€ Complex data needs / Multiple frontends
â”‚   â””â”€â”€ GraphQL (flexible queries)
â”‚
â”œâ”€â”€ TypeScript frontend + backend (monorepo)
â”‚   â””â”€â”€ tRPC (end-to-end type safety)
â”‚
â”œâ”€â”€ Real-time / Event-driven
â”‚   â””â”€â”€ WebSocket + AsyncAPI
â”‚
â””â”€â”€ Internal microservices
    â””â”€â”€ gRPC (performance) or REST (simplicity)
```

## Comparison

| Factor | REST | GraphQL | tRPC |
|--------|------|---------|------|
| **Best for** | Public APIs | Complex apps | TS monorepos |
| **Learning curve** | Low | Medium | Low (if TS) |
| **Over/under fetching** | Common | Solved | Solved |
| **Type safety** | Manual (OpenAPI) | Schema-based | Automatic |
| **Caching** | HTTP native | Complex | Client-based |

## Selection Questions

1. Who are the API consumers?
2. Is the frontend TypeScript?
3. How complex are the data relationships?
4. Is caching critical?
5. Public or internal API?


---

# Authentication Patterns

> Choose auth pattern based on use case.

## Selection Guide

| Pattern | Best For |
|---------|----------|
| **JWT** | Stateless, microservices |
| **Session** | Traditional web, simple |
| **OAuth 2.0** | Third-party integration |
| **API Keys** | Server-to-server, public APIs |
| **Passkey** | Modern passwordless (2025+) |

## JWT Principles

```
Important:
â”œâ”€â”€ Always verify signature
â”œâ”€â”€ Check expiration
â”œâ”€â”€ Include minimal claims
â”œâ”€â”€ Use short expiry + refresh tokens
â””â”€â”€ Never store sensitive data in JWT
```


---

# API Documentation Principles

> Good docs = happy developers = API adoption.

## OpenAPI/Swagger Essentials

```
Include:
â”œâ”€â”€ All endpoints with examples
â”œâ”€â”€ Request/response schemas
â”œâ”€â”€ Authentication requirements
â”œâ”€â”€ Error response formats
â””â”€â”€ Rate limiting info
```

## Good Documentation Has

```
Essentials:
â”œâ”€â”€ Quick start / Getting started
â”œâ”€â”€ Authentication guide
â”œâ”€â”€ Complete API reference
â”œâ”€â”€ Error handling guide
â”œâ”€â”€ Code examples (multiple languages)
â””â”€â”€ Changelog
```


---

# GraphQL Principles

> Flexible queries for complex, interconnected data.

## When to Use

```
âœ… Good fit:
â”œâ”€â”€ Complex, interconnected data
â”œâ”€â”€ Multiple frontend platforms
â”œâ”€â”€ Clients need flexible queries
â”œâ”€â”€ Evolving data requirements
â””â”€â”€ Reducing over-fetching matters

âŒ Poor fit:
â”œâ”€â”€ Simple CRUD operations
â”œâ”€â”€ File upload heavy
â”œâ”€â”€ HTTP caching important
â””â”€â”€ Team unfamiliar with GraphQL
```

## Schema Design Principles

```
Principles:
â”œâ”€â”€ Think in graphs, not endpoints
â”œâ”€â”€ Design for evolvability (no versions)
â”œâ”€â”€ Use connections for pagination
â”œâ”€â”€ Be specific with types (not generic "data")
â””â”€â”€ Handle nullability thoughtfully
```

## Security Considerations

```
Protect against:
â”œâ”€â”€ Query depth attacks â†’ Set max depth
â”œâ”€â”€ Query complexity â†’ Calculate cost
â”œâ”€â”€ Batching abuse â†’ Limit batch size
â”œâ”€â”€ Introspection â†’ Disable in production
```


---

# Rate Limiting Principles

> Protect your API from abuse and overload.

## Why Rate Limit

```
Protect against:
â”œâ”€â”€ Brute force attacks
â”œâ”€â”€ Resource exhaustion
â”œâ”€â”€ Cost overruns (if pay-per-use)
â””â”€â”€ Unfair usage
```

## Strategy Selection

| Type | How | When |
|------|-----|------|
| **Token bucket** | Burst allowed, refills over time | Most APIs |
| **Sliding window** | Smooth distribution | Strict limits |
| **Fixed window** | Simple counters per window | Basic needs |

## Response Headers

```
Include in headers:
â”œâ”€â”€ X-RateLimit-Limit (max requests)
â”œâ”€â”€ X-RateLimit-Remaining (requests left)
â”œâ”€â”€ X-RateLimit-Reset (when limit resets)
â””â”€â”€ Return 429 when exceeded
```


---

# Response Format Principles

> Consistency is key - choose a format and stick to it.

## Common Patterns

```
Choose one:
â”œâ”€â”€ Envelope pattern ({ success, data, error })
â”œâ”€â”€ Direct data (just return the resource)
â””â”€â”€ HAL/JSON:API (hypermedia)
```

## Error Response

```
Include:
â”œâ”€â”€ Error code (for programmatic handling)
â”œâ”€â”€ User message (for display)
â”œâ”€â”€ Details (for debugging, field-level errors)
â”œâ”€â”€ Request ID (for support)
â””â”€â”€ NOT internal details (security!)
```

## Pagination Types

| Type | Best For | Trade-offs |
|------|----------|------------|
| **Offset** | Simple, jumpable | Performance on large datasets |
| **Cursor** | Large datasets | Can't jump to page |
| **Keyset** | Performance critical | Requires sortable key |

### Selection Questions

1. How large is the dataset?
2. Do users need to jump to specific pages?
3. Is data frequently changing?


---

# REST Principles

> Resource-based API design - nouns not verbs.

## Resource Naming Rules

```
Principles:
â”œâ”€â”€ Use NOUNS, not verbs (resources, not actions)
â”œâ”€â”€ Use PLURAL forms (/users not /user)
â”œâ”€â”€ Use lowercase with hyphens (/user-profiles)
â”œâ”€â”€ Nest for relationships (/users/123/posts)
â””â”€â”€ Keep shallow (max 3 levels deep)
```

## HTTP Method Selection

| Method | Purpose | Idempotent? | Body? |
|--------|---------|-------------|-------|
| **GET** | Read resource(s) | Yes | No |
| **POST** | Create new resource | No | Yes |
| **PUT** | Replace entire resource | Yes | Yes |
| **PATCH** | Partial update | No | Yes |
| **DELETE** | Remove resource | Yes | No |

## Status Code Selection

| Situation | Code | Why |
|-----------|------|-----|
| Success (read) | 200 | Standard success |
| Created | 201 | New resource created |
| No content | 204 | Success, nothing to return |
| Bad request | 400 | Malformed request |
| Unauthorized | 401 | Missing/invalid auth |
| Forbidden | 403 | Valid auth, no permission |
| Not found | 404 | Resource doesn't exist |
| Conflict | 409 | State conflict (duplicate) |
| Validation error | 422 | Valid syntax, invalid data |
| Rate limited | 429 | Too many requests |
| Server error | 500 | Our fault |


---

# API Security Testing

> Principles for testing API security. OWASP API Top 10, authentication, authorization testing.

---

## OWASP API Security Top 10

| Vulnerability | Test Focus |
|---------------|------------|
| **API1: BOLA** | Access other users' resources |
| **API2: Broken Auth** | JWT, session, credentials |
| **API3: Property Auth** | Mass assignment, data exposure |
| **API4: Resource Consumption** | Rate limiting, DoS |
| **API5: Function Auth** | Admin endpoints, role bypass |
| **API6: Business Flow** | Logic abuse, automation |
| **API7: SSRF** | Internal network access |
| **API8: Misconfiguration** | Debug endpoints, CORS |
| **API9: Inventory** | Shadow APIs, old versions |
| **API10: Unsafe Consumption** | Third-party API trust |

---

## Authentication Testing

### JWT Testing

| Check | What to Test |
|-------|--------------|
| Algorithm | None, algorithm confusion |
| Secret | Weak secrets, brute force |
| Claims | Expiration, issuer, audience |
| Signature | Manipulation, key injection |

### Session Testing

| Check | What to Test |
|-------|--------------|
| Generation | Predictability |
| Storage | Client-side security |
| Expiration | Timeout enforcement |
| Invalidation | Logout effectiveness |

---

## Authorization Testing

| Test Type | Approach |
|-----------|----------|
| **Horizontal** | Access peer users' data |
| **Vertical** | Access higher privilege functions |
| **Context** | Access outside allowed scope |

### BOLA/IDOR Testing

1. Identify resource IDs in requests
2. Capture request with user A's session
3. Replay with user B's session
4. Check for unauthorized access

---

## Input Validation Testing

| Injection Type | Test Focus |
|----------------|------------|
| SQL | Query manipulation |
| NoSQL | Document queries |
| Command | System commands |
| LDAP | Directory queries |

**Approach:** Test all parameters, try type coercion, test boundaries, check error messages.

---

## Rate Limiting Testing

| Aspect | Check |
|--------|-------|
| Existence | Is there any limit? |
| Bypass | Headers, IP rotation |
| Scope | Per-user, per-IP, global |

**Bypass techniques:** X-Forwarded-For, different HTTP methods, case variations, API versioning.

---

## GraphQL Security

| Test | Focus |
|------|-------|
| Introspection | Schema disclosure |
| Batching | Query DoS |
| Nesting | Depth-based DoS |
| Authorization | Field-level access |

---

## Security Testing Checklist

**Authentication:**
- [ ] Test for bypass
- [ ] Check credential strength
- [ ] Verify token security

**Authorization:**
- [ ] Test BOLA/IDOR
- [ ] Check privilege escalation
- [ ] Verify function access

**Input:**
- [ ] Test all parameters
- [ ] Check for injection

**Config:**
- [ ] Check CORS
- [ ] Verify headers
- [ ] Test error handling

---

> **Remember:** APIs are the backbone of modern apps. Test them like attackers will.


---

# tRPC Principles

> End-to-end type safety for TypeScript monorepos.

## When to Use

```
âœ… Perfect fit:
â”œâ”€â”€ TypeScript on both ends
â”œâ”€â”€ Monorepo structure
â”œâ”€â”€ Internal tools
â”œâ”€â”€ Rapid development
â””â”€â”€ Type safety critical

âŒ Poor fit:
â”œâ”€â”€ Non-TypeScript clients
â”œâ”€â”€ Public API
â”œâ”€â”€ Need REST conventions
â””â”€â”€ Multiple language backends
```

## Key Benefits

```
Why tRPC:
â”œâ”€â”€ Zero schema maintenance
â”œâ”€â”€ End-to-end type inference
â”œâ”€â”€ IDE autocomplete across stack
â”œâ”€â”€ Instant API changes reflected
â””â”€â”€ No code generation step
```

## Integration Patterns

```
Common setups:
â”œâ”€â”€ Next.js + tRPC (most common)
â”œâ”€â”€ Monorepo with shared types
â”œâ”€â”€ Remix + tRPC
â””â”€â”€ Any TS frontend + backend
```


---

# Versioning Strategies

> Plan for API evolution from day one.

## Decision Factors

| Strategy | Implementation | Trade-offs |
|----------|---------------|------------|
| **URI** | /v1/users | Clear, easy caching |
| **Header** | Accept-Version: 1 | Cleaner URLs, harder discovery |
| **Query** | ?version=1 | Easy to add, messy |
| **None** | Evolve carefully | Best for internal, risky for public |

## Versioning Philosophy

```
Consider:
â”œâ”€â”€ Public API? â†’ Version in URI
â”œâ”€â”€ Internal only? â†’ May not need versioning
â”œâ”€â”€ GraphQL? â†’ Typically no versions (evolve schema)
â”œâ”€â”€ tRPC? â†’ Types enforce compatibility
```
